#!/bin/bash
set -euo pipefail

die() {
	echo "Error: $*" >&2
	exit 1
}

# build the boot files
build() {
	pushd "$root_dir" >/dev/null

	echo "Copying the boot directory"
	cp -a ./boot/* "$build_dir"

	echo "Generating the initramfs"
	find . -path ./boot -prune -o -print0 | sort -z | cpio -0oH newc | compress >"$build_dir"/initramfs

	popd >/dev/null
}

generate_bootloader_config() {
	local cmdline initrd

	echo "Generating the bootloader configuration"
	pushd "$build_dir" >/dev/null
	initrd="$(echo *.img initramfs | tr ' ' ',')"
	cmdline=$(cat cmdline && rm cmdline)
	cat >syslinux.cfg <<-EOF
	DEFAULT Linux
	LABEL Linux
	  KERNEL kernel
	  INITRD $initrd
	  APPEND ${cmdline:--}
	EOF
	popd >/dev/null
}

# compress the initramfs with the specified scheme
compress() {
	case "$compression" in
		none)
			cat
			;;
		gz)
			pigz -9
			;;
		xz)
			xz -C crc32 -9 -T0
			;;
		zstd)
			zstd -19 -T0
			;;
		*)
			die "invalid compression scheme '$compression'"
			;;
	esac
}

# just copy the build files to the output directory
generate_files() {
	echo "Copying the OS files to the output directory"
	mv "$build_dir" "$output"
}

# generate a raw disk image with a MBR and a single whole disk partition
generate_raw() {
	local disk_file part_file build_dir_size part_size disk_size

	generate_bootloader_config

	disk_file="$output".img
	part_file="$output".part.img
	build_dir_size=$(du -sk "$build_dir" | cut -f1)  # in KB

	# add some headroom to account for the filesystem overhead (less than 2%) & the missing bootloader files
	part_size=$(( (build_dir_size + 512) * 102 / 100  ))

	echo "Generating the disk image"
	echo "boot partition size is $part_size K"

	# create a FAT32 filesystem
	mkfs.vfat -n "$volume" -F 32 -C "$part_file" $part_size -v
	# copy the system boot files (i.e. kernel, initramfs, etc.)
	mcopy -i "$part_file" "$build_dir"/* ::/
	# copy the 2nd stage bootloader
	syslinux --install "$part_file"

	# compute the disk size in bytes
	# add 1MB to account for the partition offset
	# leave 1MB at the end to make sure that the partition fits (seems necessary, not sure why)
	disk_size=$(( (part_size + 2 * 1024) * 1024 ))

	# create a blank image file
	dd if=/dev/zero of="$disk_file" bs=$disk_size count=1 conv=notrunc status=none

	# add a single full disk partition formatted as FAT32 with LBA
	echo "start=1MiB type=0c bootable" | sfdisk --no-reread --label dos "$disk_file"

	# copy in our partition data into the first partition of the disk image
	dd if="$part_file" of="$disk_file" bs=1M seek=1 conv=notrunc status=none

	# copy the 1st stage bootloader in the MBR
	dd if="$syslinux_dir"/mbr.bin of="$disk_file" bs=440 count=1 conv=notrunc status=none

	rm -rf "$part_file"
}

# generate an hybrid ISO image
generate_iso() {
	generate_bootloader_config

	echo "Generating the iso image"

	mkdir -p "$build_dir"/syslinux
	cp "$syslinux_dir"/isolinux.bin "$syslinux_dir"/ldlinux.c32 "$build_dir"/syslinux

	# see https://wiki.syslinux.org/wiki/index.php?title=Isohybrid
	xorrisofs \
	-output "$output".iso \
	-isohybrid-mbr "$syslinux_dir"/isohdpfx.bin \
	-eltorito-catalog syslinux/boot.cat \
	-eltorito-boot syslinux/isolinux.bin \
	-no-emul-boot \
	-boot-load-size 4 \
	-boot-info-table \
	-joliet \
	-full-iso9660-filenames \
	-rational-rock \
	-sysid LINUX \
	-volid "$volume" \
	"$build_dir"

	# TODO: add UEFI options, or create a separate format to support UEFI iso
	# -eltorito-alt-boot \
 	# -eltorito-platform 0xEF \
 	# -eltorito-boot syslinux/efiboot.img \
 	# -isohybrid-gpt-basdat \
}

set_format() {
	case "$1" in
		raw|iso|files)
			format="$1"
			;;
		*)
			die "invalid format '$1'"
			;;
	esac
}

# defaults
syslinux_dir=/usr/share/syslinux
root_dir=/system
output=/out/claylinux
format=raw
volume=CLAYLINUX
compression=gz

usage=$(cat <<-EOF
	Usage: $(basename "$0") [OPTIONS ...]

	Options:
	  -f, --format FORMAT        Output format: raw | iso | files (default: $format)
	  -o, --output OUTPUT        Output image path/name, without any extension (default: $output)
	  -r, --root DIR             Directory containing the root filesystem (default: $root_dir)
	  -v, --volume VOLUME        Volume name/label of the boot partition (default: $volume)
	  -c, --compression COMP     Compression format for the initramfs: none | gz | xz | zstd (default: $compression)

	Output formats:
	  - raw: raw disk image with a single FAT32 boot partition (saved as OUTPUT.img)
	  - iso: ISO9660 CD-ROM image (saved as OUTPUT.iso)
	  - files: kernel & initramfs files (saved in OUTPUT directory), for use with a custom boot/bootloader (e.g. PXE)
	EOF
)

# parse the command-line arguments
while [[ "$#" -gt 0 ]]; do
	case "$1" in
		-h|--help)
			echo "$usage"
			exit 0
			;;
		-f|--format)
			set_format "$2"
			shift 2
			;;
		-o|--output)
			output="$2"
			shift 2
			;;
		-r|--root)
			root_dir="$2"
			shift 2
			;;
		-v|--volume)
			volume="$2"
			shift 2
			;;
		-c|--compression)
			compression="$2"
			shift 2
			;;
		-*)
			die "invalid option '$1'"
			;;
		*)
			die "invalid parameter '$1'"
			;;
	esac
done

[[ -d "$root_dir" ]] || die "the root directory '$root_dir' does not exist"

build_dir=$(mktemp -d)
trap 'rm -rf $build_dir' EXIT
build
mkdir -p "$(dirname "$output")"
generate_"$format"
