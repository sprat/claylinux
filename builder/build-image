#!/bin/bash
set -euo pipefail

# exit with an error message
die() {
	echo "Error: $*" >&2
	exit 1
}

# build the boot files
build() {
	pushd "$root_dir" >/dev/null

	echo "Copying the boot directory"
	cp -a ./boot/* "$build_dir"

	echo "Generating the initramfs"
	find . -path ./boot -prune -o -print0 | sort -z | cpio -0oH newc | compress >"$build_dir"/initramfs.img

	popd >/dev/null
}

# find the kernel file
find_kernel() {
	find . -name 'vmlinu*' -print | cut -c3-
}

# find the initrd images files
find_initrd_images() {
	find . -name '*-ucode.img' -print | cut -c3-
	find . -name initramfs.img -print | cut -c3-
}

# add a prefix to each line
add_prefix() {
	sed -e "s|^|$1|"
}

# format and delete the cmdline
format_and_delete_cmdline() {
	result=$(space_separated <cmdline)
	rm cmdline
	echo "$result"
}

# convert a multi-line input into a comma separated list
comma_separated() {
	paste -d, -s
}

# convert a multi-line input into a space separated list
space_separated() {
	paste -d' ' -s
}

# generate the bootloader config
generate_bootloader_config() {
	echo "Generating the bootloader configuration"

	pushd "$build_dir" >/dev/null

	cat >limine.cfg <<-EOF
	TIMEOUT=0
	GRAPHICS=no
	SERIAL=yes

	:Linux
	PROTOCOL=linux
	$(find_kernel | add_prefix 'KERNEL_PATH=boot:///')
	$(find_initrd_images | add_prefix 'MODULE_PATH=boot:///')
	KERNEL_CMDLINE=$(format_and_delete_cmdline)
	EOF

	popd >/dev/null
}

# generate a boot environment
generate_boot_env() {
	pushd "$build_dir" >/dev/null

	echo "Generating the boot env file"""

	cat >boot.env <<-EOF
	KERNEL="$(find_kernel)"
	INITRD="$(find_initrd_images | space_separated)"
	CMDLINE="$(format_and_delete_cmdline)"
	EOF

	popd >/dev/null
}

# compress the initramfs with the specified scheme
compress() {
	case "$compression" in
		none)
			cat
			;;
		gz)
			pigz -9
			;;
		xz)
			xz -C crc32 -9 -T0
			;;
		zstd)
			zstd -19 -T0
			;;
		*)
			die "invalid compression scheme '$compression'"
			;;
	esac
}

# just copy the build files to the output directory
generate_files() {
	echo "Copying the OS files to the output directory"
	generate_boot_env
	mv "$build_dir" "$output"
}

# generate a raw disk image with a MBR and a single whole disk partition
generate_raw() {
	local disk_file part_file files_size part_size disk_size

	generate_bootloader_config

	disk_file="$output".img
	part_file="$output".part.img

	files_size=$(du -sb "$build_dir" | cut -f1)  # apparent size in bytes
	# compute the boot partition size:
	# - add some headroom to account for the filesystem overhead (less than 2%)
	# - add 512K for the bootloader files which are not taken into account in the calculation
	# - round to the next MiB (1<<20)
	# - convert the result to MiB
	part_size=$(( ((files_size * 102 / 100 + (1<<19)) + (1<<20) - 1) >> 20 ))
	# compute the disk size in bytes: add 1MB at both ends for the partition tables
	disk_size=$(( part_size + 2 ))

	echo "Generating the disk image"
	echo "The size of the boot partition will be ${part_size} MiB"

	# create a FAT32 filesystem
	mkfs.vfat -n "$volume" -F 32 -C "$part_file" "$(( part_size << 10 ))" -v
	# copy the system boot files (i.e. kernel, initramfs, etc.)
	mcopy -i "$part_file" "$build_dir"/* ::/
	# copy the 2nd stage bootloader
	mmd -i "$part_file" ::/limine
	mcopy -i "$part_file" "$limine_dir"/limine.sys ::/limine

	# create a blank image file
	truncate -s ${disk_size}M "$disk_file"

	# add a single full disk partition formatted as FAT32 with LBA
	sfdisk --no-reread --label dos "$disk_file" <<-EOF
	start=1MiB size=${part_size}MiB type=0c bootable
	EOF

	# copy in our partition data into the first partition of the disk image
	dd if="$part_file" of="$disk_file" bs=1M seek=1 conv=notrunc status=none

	# delete the part file
	rm -rf "$part_file"

	# copy the 1st stage bootloader in the MBR
	limine-deploy "$disk_file"
}

# generate a disk image in qcow2 format
generate_qcow2() {
	generate_raw

	echo "Converting the disk image to qcow2 format"
	qemu-img convert -f raw -O qcow2 "$output".img "$output".qcow2
	rm "$output".img
}

# generate an hybrid ISO image
generate_iso() {
	generate_bootloader_config

	echo "Generating the iso image"

	mkdir -p "$build_dir"/limine
	cp "$limine_dir"/limine.sys "$limine_dir"/limine-cd.bin "$limine_dir"/limine-cd-efi.bin "$build_dir"/limine

	xorrisofs \
	-eltorito-boot limine/limine-cd.bin \
	-no-emul-boot \
	-boot-load-size 4 \
	-boot-info-table \
	--efi-boot limine/limine-cd-efi.bin \
	-efi-boot-part --efi-boot-image \
	--protective-msdos-label \
	-joliet \
	-full-iso9660-filenames \
	-rational-rock \
	-sysid LINUX \
	-volid "$volume" \
	-output "$output".iso \
	"$build_dir"

	limine-deploy "$output".iso
}

# validate and set the output format
set_format() {
	case "$1" in
		raw|qcow2|iso|files)
			format="$1"
			;;
		*)
			die "invalid format '$1'"
			;;
	esac
}

# defaults
limine_dir=/usr/share/limine
root_dir=/system
output=/out/claylinux
format=raw
volume=CLAYLINUX
compression=gz

usage=$(cat <<-EOF
	Usage: $(basename "$0") [OPTIONS ...]

	Options:
	  -f, --format FORMAT        Output format: raw | iso | files (default: $format)
	  -o, --output OUTPUT        Output image path/name, without any extension (default: $output)
	  -r, --root DIR             Directory containing the root filesystem (default: $root_dir)
	  -v, --volume VOLUME        Volume name/label of the boot partition (default: $volume)
	  -c, --compression COMP     Compression format for the initramfs: none | gz | xz | zstd (default: $compression)

	Output formats:
	  - raw: raw disk image with a single FAT32 boot partition (saved as OUTPUT.img)
	  - qcow2: disk image in QCOW2 format (saved as OUTPUT.qcow2)
	  - iso: ISO9660 CD-ROM image (saved as OUTPUT.iso)
	  - files: kernel & initramfs files (saved in OUTPUT directory), for use with a custom boot/bootloader (e.g. PXE)
	EOF
)

# parse the command-line arguments
while [[ "$#" -gt 0 ]]; do
	case "$1" in
		-h|--help)
			echo "$usage"
			exit 0
			;;
		-f|--format)
			set_format "$2"
			shift 2
			;;
		-o|--output)
			output="$2"
			shift 2
			;;
		-r|--root)
			root_dir="$2"
			shift 2
			;;
		-v|--volume)
			volume="$2"
			shift 2
			;;
		-c|--compression)
			compression="$2"
			shift 2
			;;
		-*)
			die "invalid option '$1'"
			;;
		*)
			die "invalid parameter '$1'"
			;;
	esac
done

[[ -d "$root_dir" ]] || die "the root directory '$root_dir' does not exist"

build_dir=$(mktemp -d)
trap 'rm -rf $build_dir' EXIT
build
mkdir -p "$(dirname "$output")"
generate_"$format"
