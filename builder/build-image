#!/bin/bash
set -euo pipefail

die() {
	echo "$@" >&2
	exit 1
}

# build the boot files
build() {
	local cmdline initrd

	pushd "$system_dir" >/dev/null

	echo "Copying the boot directory"
	find ./boot -mindepth 1 -maxdepth 1 ! -name cmdline -exec cp -at "$build_dir" {} +

	echo "Generating the initramfs"
	find . -path ./boot -prune -o -print0 | sort -z | cpio -0oH newc | compress >"$build_dir"/initramfs

	popd >/dev/null

	echo "Generating the bootloader configuration"
	pushd "$build_dir" >/dev/null
	initrd="$(echo *.img initramfs | tr ' ' ',')"
	cmdline=$(tr '\n' ' ' <"$system_dir"/boot/cmdline)
	[[ -z "$cmdline" ]] && cmdline="-"
	cat >syslinux.cfg <<-EOF
	DEFAULT Linux
	LABEL Linux
	  KERNEL kernel
	  INITRD $initrd
	  APPEND $cmdline
	EOF
	popd >/dev/null
}

# compress the initramfs with the specified scheme
compress() {
	case "$compression" in
	none)
		cat
		;;
	gz)
		pigz -9
		;;
	xz)
		xz -C crc32 -9 -T0
		;;
	zstd)
		zstd -19 -T0
		;;
	*)
		die "Invalid compression scheme: $compression"
		;;
	esac
}

# just copy the build files to the output directory
generate_files() {
	echo "Copying the OS files to the output directory"
	mv "$build_dir"/* "$output_dir"
}

# generate a raw disk image with a MBR and a single whole disk partition
generate_raw() {
	local disk_file="$output_dir"/"$name".img part_file build_dir_size part_size disk_size

	part_file="$disk_file".part
	build_dir_size=$(du -sk "$build_dir" | cut -f1)  # in KB

	# add some headroom to account for the filesystem overhead (less than 2%) & the missing bootloader files
	part_size=$(( (build_dir_size + 512) * 102 / 100  ))

	echo "Generating the disk image"
	echo "boot partition size is $part_size K"

	# create a FAT32 filesystem
	mkfs.vfat -n "$volume" -F 32 -C "$part_file" $part_size -v
	# copy the system boot files (i.e. kernel, initramfs, etc.)
	mcopy -i "$part_file" "$build_dir"/* ::/
	# copy the 2nd stage bootloader
	syslinux --install "$part_file"

	# compute the disk size in bytes
	# add 1MB to account for the partition offset
	# leave 1MB at the end to make sure that the partition fits (seems necessary, not sure why)
	disk_size=$(( (part_size + 2 * 1024) * 1024 ))

	# create a blank image file
	dd if=/dev/zero of="$disk_file" bs=$disk_size count=1 conv=notrunc status=none

	# add a single full disk partition formatted as FAT32 with LBA
	echo "start=1MiB type=0c bootable" | sfdisk --no-reread --label dos "$disk_file"

	# copy in our partition data into the first partition of the disk image
	dd if="$part_file" of="$disk_file" bs=1M seek=1 conv=notrunc status=none

	# copy the 1st stage bootloader in the MBR
	dd if="$syslinux_dir"/mbr.bin of="$disk_file" bs=440 count=1 conv=notrunc status=none

	rm -rf "$part_file"
}

# generate an hybrid ISO image
generate_iso() {
	local iso_file="$output_dir"/"$name".iso

	echo "Generating the iso image"

	mkdir -p "$build_dir"/syslinux
	cp "$syslinux_dir"/isolinux.bin "$syslinux_dir"/ldlinux.c32 "$build_dir"/syslinux

	# see https://wiki.syslinux.org/wiki/index.php?title=Isohybrid
	xorrisofs \
	-output "$iso_file" \
	-isohybrid-mbr "$syslinux_dir"/isohdpfx.bin \
	-eltorito-catalog syslinux/boot.cat \
	-eltorito-boot syslinux/isolinux.bin \
	-no-emul-boot \
	-boot-load-size 4 \
	-boot-info-table \
	-joliet \
	-full-iso9660-filenames \
	-rational-rock \
	-sysid LINUX \
	-volid "$volume" \
	"$build_dir"

	# TODO: add UEFI options, or create a separate format to support UEFI iso
	# -eltorito-alt-boot \
 	# -eltorito-platform 0xEF \
 	# -eltorito-boot syslinux/efiboot.img \
 	# -isohybrid-gpt-basdat \
}

set_format() {
	case "$1" in
	raw|iso|files)
		format="$1"
		;;
	*)
		die "Invalid format: $1"
		;;
	esac
}

# defaults
system_dir=/system
output_dir=/out
syslinux_dir=/usr/share/syslinux
format=raw
name=claylinux
volume=CLAYLINUX
compression=gz

usage=$(cat <<-EOF
	Usage: $0 [OPTIONS ...]

	Options:
	  -f, --format FORMAT       Output format: raw | iso | files (default: $format)
	  -n, --name NAME           Image file basename (default: $name)
	  -v, --volume VOLUME       Volume name/label of the boot partition (default: $volume)
	  -c, --compression COMP    Compression format for the initramfs: none | gz | xz | zstd

	Output formats:
	  - raw: raw disk image with a single FAT32 boot partition (filename: NAME.img)
	  - iso: ISO9660 CD-ROM image (filename: NAME.iso)
	  - files: kernel & initramfs files as is, to be copied into a bootable partition (name not used)
	EOF
)

# parse the command-line arguments
while [[ "$#" -gt 0 ]]; do
	case "$1" in
		-h|--help)
			echo "$usage"
			exit 0
			;;
		-f|--format)
			set_format "$2"
			shift 2
			;;
		-n|--name)
			name="$2"
			shift 2
			;;
		-v|--volume)
			volume="$2"
			shift 2
			;;
		-c|--compression)
			compression="$2"
			shift 2
			;;
		-*)
			die "Invalid option: $1"
			;;
		*)
			die "Invalid parameter: $1"
			;;
	esac
done

mkdir -p "$output_dir"
build_dir=$(mktemp -d)
trap 'rm -rf $build_dir' EXIT
build
generate_"$format"
