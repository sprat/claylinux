#!/bin/bash
set -euo pipefail

die() {
	echo "$@" >&2
	exit 1
}

# build the boot files
build() {
	local cmdline initrd

	pushd "$system_dir" >/dev/null

	echo "Copying the boot directory"
	find ./boot -mindepth 1 -maxdepth 1 ! -name cmdline -exec cp -at "$build_dir" {} +

	echo "Generating the initramfs"
	find . -path ./boot -prune -o -print | sort | cpio -oH newc | compress >"$build_dir"/initramfs

	popd >/dev/null

	echo "Generating the syslinux configuration"
	pushd "$build_dir" >/dev/null
	initrd="$(echo *.img initramfs | tr ' ' ',')"
	cmdline=$(tr '\n' ' ' <"$system_dir"/boot/cmdline)
	[[ -z "$cmdline" ]] && cmdline="-"
	cat >syslinux.cfg <<-EOF
	DEFAULT Linux
	LABEL Linux
	  KERNEL kernel
	  INITRD $initrd
	  APPEND $cmdline
	EOF
	popd >/dev/null
}

# compress the initramfs with the specified scheme
compress() {
	case "$compression" in
	none)
		cat
		;;
	gz)
		pigz -9
		;;
	xz)
		xz -C crc32 -9 -T0
		;;
	zstd)
		zstd -19 -T0
		;;
	*)
		die "Invalid compression scheme: $compression"
		;;
	esac
}

# just copy the build files to the output directory
generate_files() {
	echo "Copying the OS files to the output directory"
	mv "$build_dir"/* "$output_dir"
}

# generate a disk image with a MBR and a single whole disk partition
generate_img() {
	disk_file="$output_dir"/"$name".img
	disk_label=dos  # for sfdisk
	syslinux_mbr="$syslinux_dir"/mbr.bin
	syslinux_mbr_length=440
	part_file=/tmp/part.img
	boot_dir_size=$(du -sk "$build_dir" | cut -f1)  # in KB
	# add some headroom to account for the filesystem overhead & the missing syslinux bootloader files
	part_size=$(( boot_dir_size + 4 * 1024 ))

	echo "Generating the disk image"

	# create a FAT32 filesystem
	mkdir -p "$(dirname $part_file)"
	mkfs.vfat -n "$volume" -F 32 -C $part_file $part_size
	# copy the system boot files (i.e. kernel, initramfs, etc.)
	mcopy -i $part_file "$build_dir"/* ::/
	# copy the syslinux bootloader
	syslinux --install $part_file

	# compute the disk size
	part_size=$(stat -c %s "$part_file")
	disk_size=$(( part_size + 2 * 1024 * 1024 ))

	# create a blank image file
	dd if=/dev/zero of="$disk_file" bs=$disk_size count=1 conv=notrunc

	# add a single full disk partition formatted as FAT32 -- 0c = FAT32 with LBA
	sfdisk "$disk_file" <<-EOF
	label: $disk_label
	2MiB - 0c *
	EOF

	# overwrite the MBR
	dd if=$syslinux_mbr of="$disk_file" bs=$syslinux_mbr_length count=1 conv=notrunc

	# copy in our partition data into the first partition of the disk image
	dd if=$part_file of="$disk_file" bs=2M seek=1 conv=notrunc

	rm -rf $part_file
}

# generate an hybrid ISO image
generate_iso() {
	iso_file="$output_dir"/"$name".iso

	echo "Generating the iso image"

	mkdir -p "$build_dir"/syslinux
	cp "$syslinux_dir"/isolinux.bin "$syslinux_dir"/ldlinux.c32 "$build_dir"/syslinux

	# see https://wiki.syslinux.org/wiki/index.php?title=Isohybrid
	xorrisofs \
	-output "$iso_file" \
	-isohybrid-mbr "$syslinux_dir"/isohdpfx.bin \
	-eltorito-catalog syslinux/boot.cat \
	-eltorito-boot syslinux/isolinux.bin \
	-no-emul-boot \
	-boot-load-size 4 \
	-boot-info-table \
	-joliet \
	-full-iso9660-filenames \
	-rational-rock \
	-sysid LINUX \
	-volid "$volume" \
	"$build_dir"
}

usage() {
	cat <<-EOF
	Usage: $0 [OPTIONS ...]

	Options:
	  -f, --format FORMAT       Output format: files | img | iso (default: "$format")
	  -n, --name NAME           Image filename (default: "$name")
	  -v, --volume VOLUME       Volume name/label of the boot partition (default: "$volume")
	  -c, --compression COMP    Compression format for the initramfs: none | gz | xz | zstd
	EOF
}

# defaults
system_dir=/system
output_dir=/out
syslinux_dir=/usr/share/syslinux
format=iso
name=claylinux
volume=CLAYLINUX
compression=gz

# parse the command-line arguments
while [[ "$#" -gt 0 ]]; do
	case "$1" in
		-h|--help)
			usage
			exit 0
			;;
		-f|--format)
			format="$2"
			shift 2
			;;
		-n|--name)
			name="$2"
			shift 2
			;;
		-v|--volume)
			volume="$2"
			shift 2
			;;
		-c|--compression)
			compression="$2"
			shift 2
			;;
		-*)
			die "Invalid option: $1"
			;;
		*)
			die "Invalid parameter: $1"
			# POSITIONAL_ARGS+=("$1")
			# shift
			;;
	esac
done
# set -- "${POSITIONAL_ARGS[@]}" # restore positional parameters

mkdir -p "$output_dir"
build_dir=$(mktemp -d)
trap 'rm -rf $build_dir' EXIT
build
generate_"$format"
